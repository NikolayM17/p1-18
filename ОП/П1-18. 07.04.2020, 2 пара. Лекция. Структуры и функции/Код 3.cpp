#include <stdio.h>
#include <stdlib.h>

/// Допустим описана подобная структура
typedef struct Termin
{
    int day;   /// день месяца
    int month; /// месяц года
    int year;   /// год
} Date;

/// Функция печати даты
/// функция принимает объект struct Termin
/// вместо struct Termin можно использовать
/// синоним Date
void printDate(struct Termin day){
    /// при вызове функции с параметром, значения всех
    /// полей копируется в соответствующие поля объекта a
    printf("%04d-%02d-%02d\n", day.year, day.month, day.day);
};

/// Функция получения даты
/// функция принимает указатель на объект типа Date
/// Это позволит изменять значения переменной по адресу
void getDate(Date* a){
    /// при вызове функции с параметром указателем
    /// в переменную-указатель копируется адрес объекта
    /// Таким образом scanf работает с адресом
    /// a->year - получение ЗНАЧЕНИЯ атрибута ПО АДРЕСУ объекта
    /// &(a->year) - получение адреса атрибута,
    /// можно писать &a->year, приоритет оператора -> выше, чем у &
    scanf("%d%d%d", &(a->year), &(a->month), &(a->day));
};

int main(){
    Date dt; /// объект дата

    /// получение значений атрибутов с консоли
    /// парметр - адрес dt
    /// значение dt в main() меняется функцией getDate()
    getDate(&dt);

    // вызов функции printDate(), параметр функции - dt
    // значение dt копируется в локальную переменную функции
    // значение dt в main() не меняется
    printDate(dt);

    return 0;
}

Роголев В.А. П1-18 29-04-2020 
Многомерные встроенные массивы

C++ позволяет определять многомерные массивы:

int m2d [2][3] = { {1, 2, 3}, {4, 5, 6} };
for ( size_t i = 0; i != 2; ++i ) {
    for ( size_t j = 0; j != 3; ++j ) {
        cout << m2d[i][j] << ’ ’;
    }
    cout << endl ;
}

Для выделения одномерных динамических массивов
обычно используется оператор new [].
int * m1d = new int [100];

создание массива 5 х 4.
int ** m = new int * [5];
for ( size_t i = 0; i != 5; ++i)
    m[i] = new int [4];


Выделение двумерного массива размера a х b.
int ** create_array2d ( size_t a, size_t b) {
    int ** m = new int *[a];
    for ( size_t i = 0; i != a; ++i)
        m[i] = new int[b];
    return m;
}

освобождение двумерного массива размера a х b.
void free_array2d (int ** m, size_t a, size_t b) {
    for ( size_t i = 0; i != a; ++i)
        delete [] m[i];
    delete [] m;
}

эффективное создание массива 5 х 4.
int ** m = new int * [5];
m[0] = new int [5 * 4];
for ( size_t i = 1; i != 5; ++i)
    m[i] = m[i - 1] + 4;

Эффективное выделение двумерного массива размера a х b.
int ** create_array2d ( size_t a, size_t b) {
    int ** m = new int *[a];
    m[0] = new int[a * b];
    for ( size_t i = 1; i != a; ++i)
        m[i] = m[i - 1] + b;
    return m;
}
Эффективное освобождение двумерного массива размера a х b.
void free_array2d (int ** m, size_t a, size_t b) {
    delete [] m [0];
    delete [] m;
}

Многомерные массивы в C++ можно создавать не только в динамической памяти, но и на стеке. Это делается так же, как и с одномерными массивами:

int a[5][3];
cout << a[1][1] << " " << a[1][2] << endl;
Если массив будет проинициализирован сразу при определении, то его внешнюю размерность можно не указывать:
int a[][3] = { {1, 2, 3}, {4, 5, 6}, {7, 8, 9} };
Многомерный массив на стеке можно проинициализировать ещё и следующим, казалось бы, необычным образом:
int a[][3] = { 1, 2, 3, 4, 5, 6, 7, 8, 9 };

Дело в том, что многомерные массивы на стеке отличаются от показанных вам на лекции многомерных массивов в динамической памяти — многомерный массив на стеке хранится в непрерывном участке памяти (ему не требуется индексной таблицы с указателями).
Давайте рассмотрим на примере двумерного массива:
    int a[N][M];
В памяти в начале такого массива хранятся M элементов 0-ой строки, затем M элементов 1-ой строки, затем M элементов 2-ой строки и так далее до строки с номером N - 1 включительно. 
Другими словами, двумерный массив размера N х M представлен в памяти так же, как и одномерный массив размера NM, поэтому второй вариант инициализации массива эквивалентен первому.
Пользуясь этим знанием, мы теперь можем понять, почему две следующие строки эквивалентны.
    *((int *)a + i * M + j) = 1;
    a[i][j] = 1;